## Intro Blog UV-init
# Tools to set up a modern python research software project

I'm not a software developer, I am a scientist who likes developing tools for image analysis and bioinformatics. I learned Python during the lockdown when I suddenly had time on my hands and nothing better to do. Like most scientists starting with Python I used Jupyter notebooks, writing spaghetti code one cell at a time. This became frustrating very quickly. So I looked into more convenient ways to reuse functions and eventually classes and methods. This led me to learn about python modules and __init__.py files landing me in software development territory.  I have to admit this transition didn’t come easy. Its like moving to a different country! At the beginning of your coding journey you are mostly concerned about for-loops, conditionals, recursion, function and classes and other basic concepts of computer programming. But to actually develop software you have to become comfortable with the terminal, virtual environments, learn git, maybe even docker, start worrying about type hints, code style, error handling and logging, not to speak of pre-commit hooks and continuous integration. It’s a long journey.
I started to work on high content image analysis project that grew larger and larger and was in constant use in the lab while it was growing. In a way this was a blessing since i had to write code that others used and git instant feedback.
The first hurdle is actually python itself. There are just too many ways to run Python code. I worked with conda at first and also looked into pyenv for a bit, only half knowing what I was doing. In parallel I started learning Rust (mainly out of curiosity) and the native packaging system, cargo, seemed such a logical and simple way to set up a project. Then uv appeared and it felt like things were falling into place. By that time my image analysis project had grown into several repos and I started to co-develop with others so my gitwork flows and project management skills had to improve.
In the end I decided to start from scratch and build my own version of a project cookie cutter project that handles my tooling needs with different levels of depth, from a simple notebook/data-analysi project. to a full fledged mono-repo with recommit hooks, testing and CI. I like learning by doing. So it seemed logical to build a small application that automates the project set up. This let me catch two birds with one stone: I familiarise myself with some fundamental tools that support modern python software development, and I generated a little package that helps me quickly get started with new projects. Of note, there are much more professional cookie cutter tools out there and Im not in the business to compete or write the next big thing in Python tooling. Creating uv-init was mainly a self learning project with the aim of building an app that is useful for my own needs.

This blog is my documentation of this process. I will summarise the different steps of building the project and refer to more detailed documentation as I go along. I’ll summarise the major tools briefly below and will go into more depth for each topic in separate units. What I hope to achieve here is to give a practical overview of setting up a modern python project that is ready to go with state of the art tools for productive software development. My main sources for a lot of the topics covered here were python podcasts and courses from talkpython and real python. These let me to other peoples blogs and resources, so in the end I learned a lot from other people efforts to teach and share knowledge. In return, perhaps a few people will find some helpful stuff here. Im aiming this at researchers coming from biosciences and working at the border of data science and software development. But starting developers from other areas may find something useful here as well.

—

I'm not a software developer - I’m a scientist who writes code for image analysis and bioinformatics. I taught myself Python during lockdown, starting the way most scientists do: Jupyter notebooks, one cell at a time. That approach works fine for exploratory analysis, but once I tried to reuse code across projects and collaborate with others, things started to fall apart quickly. I realised I needed .py files, modules, proper structure, and something resembling actual software development practices.
So just when I started being comfortable with Python I realised that there is yet another steep learning hill to climb. Moving from "how do I write a for-loop?" to "how do I set up a professional Python project?" felt like relocating to a foreign country. Suddenly I needed to understand virtual environments, package managers, git workflows, type hints, code formatting, testing, logging, pre-commit hooks, continuous integration - the list kept growing. Each tool solved a real problem, but figuring out which ones to use and how they fit together was overwhelming.
For years, I fumbled with conda and various setups, never quite satisfied. Then I started learning Rust out of curiosity, and discovered cargo—its native package manager. The elegance of that workflow was revelatory. Around the same time, uv appeared on the horizon, a new Python package manager that borrowed cargo's philosophy. Suddenly, things clicked into place.
By then, my projects had grown substantially and I was collaborating with others. Yet, I kept wrestling with the same setup problems on every new project. Rather than use an existing cookie cutter tool, I decided to build one tailored to my needs. This served two purposes: I'd learn modern Python development practices by actually using them, and I'd create something genuinely useful for my own work.
This blog documents that journey. I'm not trying to compete with professional tools or become a Python packaging expert—far from it. My goal is to share what I learned in a way that's useful for researchers like me: people who want to write good code but didn't start their careers planning to become software developers. I'll walk through each major tool and show how they fit together into a coherent workflow. If you're a researcher struggling with Python tooling, a data scientist moving toward maintainable code, or a budding developer curious about how practitioners in other fields approach these problems, hopefully you'll find something useful here.

¡€
